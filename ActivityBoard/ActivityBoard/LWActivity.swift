//
//  LWActivity.swift
//  ProjectName
//
//  Created by luowei on 2016/10/18.
//  Copyright (c) 2016 wodedata. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class LWActivity : NSObject {

    static var moveLevel: CGFloat = 0
    static var exerciseLevel: CGFloat = 0
    static var standLevel: CGFloat = 0
    
    //// Drawing Methods

    public class func drawActivityCanvas() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let red = UIColor(red: 0.976, green: 0.196, blue: 0.518, alpha: 1.000)
        let green = UIColor(red: 0.655, green: 0.988, blue: 0.196, alpha: 1.000)
        let blue = UIColor(red: 0.161, green: 0.937, blue: 0.906, alpha: 1.000)
        let red2 = UIColor(red: 1.000, green: 0.536, blue: 0.536, alpha: 1.000)
        let green2 = UIColor(red: 0.510, green: 0.939, blue: 0.388, alpha: 1.000)
        let blue2 = UIColor(red: 0.370, green: 0.805, blue: 0.856, alpha: 1.000)

        //// Gradient Declarations
        let moveGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [red.CGColor, red2.CGColor], [0, 1])!
        let exerciseGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [green2.CGColor, green.CGColor], [0, 1])!
        let standGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [blue2.CGColor, blue.CGColor], [0, 1])!

        //// Variable Declarations
        let moveDash: CGFloat = moveLevel * 387 < 2 ? 2 : moveLevel * 387
        let exerciseDash: CGFloat = exerciseLevel * 277 < 2 ? 2 : exerciseLevel * 277
        let standDash: CGFloat = standLevel * 164 < 2 ? 2 : standLevel * 164

        //// Group
        //// MaskOval Drawing
        let maskOvalPath = UIBezierPath(ovalInRect: CGRect(x: 10, y: 10, width: 140, height: 140))
        CGContextSaveGState(context!)
        maskOvalPath.addClip()
        CGContextDrawLinearGradient(context!, moveGradient, CGPoint(x: 80, y: 10), CGPoint(x: 80, y: 150), CGGradientDrawingOptions())
        CGContextRestoreGState(context!)
        UIColor.blackColor().setStroke()
        maskOvalPath.lineWidth = 1
        maskOvalPath.stroke()


        //// ExerciseOval Drawing
        let exerciseOvalPath = UIBezierPath(ovalInRect: CGRect(x: 27, y: 27, width: 106, height: 106))
        CGContextSaveGState(context!)
        exerciseOvalPath.addClip()
        CGContextDrawLinearGradient(context!, exerciseGradient, CGPoint(x: 80, y: 27), CGPoint(x: 80, y: 133), CGGradientDrawingOptions())
        CGContextRestoreGState(context!)
        UIColor.blackColor().setStroke()
        exerciseOvalPath.lineWidth = 1
        exerciseOvalPath.stroke()


        //// StandOval Drawing
        let standOvalPath = UIBezierPath(ovalInRect: CGRect(x: 45, y: 45, width: 70, height: 70))
        CGContextSaveGState(context!)
        standOvalPath.addClip()
        CGContextDrawLinearGradient(context!, standGradient, CGPoint(x: 80, y: 45), CGPoint(x: 80, y: 115), CGGradientDrawingOptions())
        CGContextRestoreGState(context!)
        UIColor.blackColor().setStroke()
        standOvalPath.lineWidth = 1
        standOvalPath.stroke()




        //// MaskGroup
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 80, 80)
        CGContextRotateCTM(context!, -90 * CGFloat(M_PI) / 180)

        CGContextSetBlendMode(context!, .DestinationIn)
        CGContextBeginTransparencyLayer(context!, nil)


        //// MoveMask Drawing
        let moveMaskPath = UIBezierPath()
        moveMaskPath.moveToPoint(CGPoint(x: 61.5, y: 0))
        moveMaskPath.addCurveToPoint(CGPoint(x: -0, y: 61.5), controlPoint1: CGPoint(x: 61.5, y: 33.97), controlPoint2: CGPoint(x: 33.97, y: 61.5))
        moveMaskPath.addCurveToPoint(CGPoint(x: -61.5, y: 0), controlPoint1: CGPoint(x: -33.97, y: 61.5), controlPoint2: CGPoint(x: -61.5, y: 33.97))
        moveMaskPath.addCurveToPoint(CGPoint(x: 0, y: -61.5), controlPoint1: CGPoint(x: -61.5, y: -33.97), controlPoint2: CGPoint(x: -33.97, y: -61.5))
        moveMaskPath.addCurveToPoint(CGPoint(x: 61.5, y: 0), controlPoint1: CGPoint(x: 33.97, y: -61.5), controlPoint2: CGPoint(x: 61.5, y: -33.97))
        moveMaskPath.closePath()
        moveMaskPath.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        moveMaskPath.lineWidth = 16
        CGContextSaveGState(context!)
        CGContextSetLineDash(context!, 0, [moveDash, 387], 2)
        moveMaskPath.stroke()
        CGContextRestoreGState(context!)


        //// ExerciseMask Drawing
        let exerciseMaskPath = UIBezierPath()
        exerciseMaskPath.moveToPoint(CGPoint(x: 44, y: -0.5))
        exerciseMaskPath.addCurveToPoint(CGPoint(x: -0.5, y: 44), controlPoint1: CGPoint(x: 44, y: 24.08), controlPoint2: CGPoint(x: 24.08, y: 44))
        exerciseMaskPath.addCurveToPoint(CGPoint(x: -45, y: -0.5), controlPoint1: CGPoint(x: -25.08, y: 44), controlPoint2: CGPoint(x: -45, y: 24.08))
        exerciseMaskPath.addCurveToPoint(CGPoint(x: -0.5, y: -45), controlPoint1: CGPoint(x: -45, y: -25.08), controlPoint2: CGPoint(x: -25.08, y: -45))
        exerciseMaskPath.addCurveToPoint(CGPoint(x: 44, y: -0.5), controlPoint1: CGPoint(x: 24.08, y: -45), controlPoint2: CGPoint(x: 44, y: -25.08))
        exerciseMaskPath.closePath()
        exerciseMaskPath.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        exerciseMaskPath.lineWidth = 17
        CGContextSaveGState(context!)
        CGContextSetLineDash(context!, 0, [exerciseDash, 277], 2)
        exerciseMaskPath.stroke()
        CGContextRestoreGState(context!)


        //// StandMask Drawing
        let standMaskPath = UIBezierPath()
        standMaskPath.moveToPoint(CGPoint(x: 25.5, y: 0))
        standMaskPath.addCurveToPoint(CGPoint(x: -0, y: 25.5), controlPoint1: CGPoint(x: 25.5, y: 14.08), controlPoint2: CGPoint(x: 14.08, y: 25.5))
        standMaskPath.addCurveToPoint(CGPoint(x: -25.5, y: 0), controlPoint1: CGPoint(x: -14.08, y: 25.5), controlPoint2: CGPoint(x: -25.5, y: 14.08))
        standMaskPath.addCurveToPoint(CGPoint(x: 0, y: -25.5), controlPoint1: CGPoint(x: -25.5, y: -14.08), controlPoint2: CGPoint(x: -14.08, y: -25.5))
        standMaskPath.addCurveToPoint(CGPoint(x: 25.5, y: 0), controlPoint1: CGPoint(x: 14.08, y: -25.5), controlPoint2: CGPoint(x: 25.5, y: -14.08))
        standMaskPath.closePath()
        standMaskPath.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        standMaskPath.lineWidth = 17
        CGContextSaveGState(context!)
        CGContextSetLineDash(context!, 0, [standDash, 164], 2)
        standMaskPath.stroke()
        CGContextRestoreGState(context!)


        CGContextEndTransparencyLayer(context!)

        CGContextRestoreGState(context!)
    }

    public class func drawActivityComposition() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let red = UIColor(red: 0.976, green: 0.196, blue: 0.518, alpha: 1.000)
        var redHueComponent: CGFloat = 1,
            redSaturationComponent: CGFloat = 1,
            redBrightnessComponent: CGFloat = 1
        red.getHue(&redHueComponent, saturation: &redSaturationComponent, brightness: &redBrightnessComponent, alpha: nil)

        let red_bg = UIColor(hue: redHueComponent, saturation: redSaturationComponent, brightness: 0.3, alpha: CGColorGetAlpha(red.CGColor))
        let green = UIColor(red: 0.655, green: 0.988, blue: 0.196, alpha: 1.000)
        var greenHueComponent: CGFloat = 1,
            greenSaturationComponent: CGFloat = 1,
            greenBrightnessComponent: CGFloat = 1
        green.getHue(&greenHueComponent, saturation: &greenSaturationComponent, brightness: &greenBrightnessComponent, alpha: nil)

        let green_bg = UIColor(hue: greenHueComponent, saturation: greenSaturationComponent, brightness: 0.2, alpha: CGColorGetAlpha(green.CGColor))
        let blue = UIColor(red: 0.161, green: 0.937, blue: 0.906, alpha: 1.000)
        var blueHueComponent: CGFloat = 1,
            blueSaturationComponent: CGFloat = 1,
            blueBrightnessComponent: CGFloat = 1
        blue.getHue(&blueHueComponent, saturation: &blueSaturationComponent, brightness: &blueBrightnessComponent, alpha: nil)

        let blue_bg = UIColor(hue: blueHueComponent, saturation: blueSaturationComponent, brightness: 0.2, alpha: CGColorGetAlpha(blue.CGColor))

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.blackColor()
        shadow.shadowOffset = CGSize(width: 0.1, height: -0.1)
        shadow.shadowBlurRadius = 1

        //// Group
        //// MaskOval Drawing
        let maskOvalPath = UIBezierPath(ovalInRect: CGRect(x: 10, y: 10, width: 140, height: 140))
        red_bg.setFill()
        maskOvalPath.fill()


        //// ExerciseOval Drawing
        let exerciseOvalPath = UIBezierPath(ovalInRect: CGRect(x: 27, y: 27, width: 106, height: 106))
        green_bg.setFill()
        exerciseOvalPath.fill()
        UIColor.blackColor().setStroke()
        exerciseOvalPath.lineWidth = 1
        exerciseOvalPath.stroke()


        //// StandOval Drawing
        let standOvalPath = UIBezierPath(ovalInRect: CGRect(x: 46, y: 46, width: 68, height: 68))
        blue_bg.setFill()
        standOvalPath.fill()
        UIColor.blackColor().setStroke()
        standOvalPath.lineWidth = 1
        standOvalPath.stroke()




        //// SymbolGroup
        CGContextSaveGState(context!)
        CGContextSetBlendMode(context!, .SourceAtop)
        CGContextBeginTransparencyLayer(context!, nil)


        //// Symbol Drawing
        let symbolRect = CGRect(x: 0, y: 0, width: 160, height: 160)
        CGContextSaveGState(context!)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context!, symbolRect.origin.x, symbolRect.origin.y)

        LWActivity.drawActivityCanvas()
        CGContextRestoreGState(context!)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalInRect: CGRect(x: 63, y: 63, width: 33.5, height: 33.5))
        UIColor.blackColor().setFill()
        ovalPath.fill()


        //// Text
        //// Move Drawing
        let moveRect = CGRect(x: 27, y: 8, width: 39, height: 21)
        let moveTextContent = NSString(string: "Move")
        CGContextSaveGState(context!)
        CGContextSetShadowWithColor(context!, shadow.shadowOffset, shadow.shadowBlurRadius, (shadow.shadowColor as! UIColor).CGColor)
        let moveStyle = NSMutableParagraphStyle()
        moveStyle.alignment = .Right

        let moveFontAttributes = [NSFontAttributeName: UIFont.systemFontOfSize(UIFont.systemFontSize()), NSForegroundColorAttributeName: red, NSParagraphStyleAttributeName: moveStyle]

        let moveTextHeight: CGFloat = moveTextContent.boundingRectWithSize(CGSize(width: moveRect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: moveFontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, moveRect)
        moveTextContent.drawInRect(CGRect(x: moveRect.minX, y: moveRect.minY + (moveRect.height - moveTextHeight) / 2, width: moveRect.width, height: moveTextHeight), withAttributes: moveFontAttributes)
        CGContextRestoreGState(context!)
        CGContextRestoreGState(context!)



        //// Exercise Drawing
        let exerciseRect = CGRect(x: 10, y: 26, width: 56, height: 21)
        let exerciseTextContent = NSString(string: "Exercise")
        CGContextSaveGState(context!)
        CGContextSetShadowWithColor(context!, shadow.shadowOffset, shadow.shadowBlurRadius, (shadow.shadowColor as! UIColor).CGColor)
        let exerciseStyle = NSMutableParagraphStyle()
        exerciseStyle.alignment = .Right

        let exerciseFontAttributes = [NSFontAttributeName: UIFont.systemFontOfSize(UIFont.systemFontSize()), NSForegroundColorAttributeName: green, NSParagraphStyleAttributeName: exerciseStyle]

        let exerciseTextHeight: CGFloat = exerciseTextContent.boundingRectWithSize(CGSize(width: exerciseRect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: exerciseFontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, exerciseRect)
        exerciseTextContent.drawInRect(CGRect(x: exerciseRect.minX, y: exerciseRect.minY + (exerciseRect.height - exerciseTextHeight) / 2, width: exerciseRect.width, height: exerciseTextHeight), withAttributes: exerciseFontAttributes)
        CGContextRestoreGState(context!)
        CGContextRestoreGState(context!)



        //// Stand Drawing
        let standRect = CGRect(x: 27, y: 44, width: 39, height: 21)
        let standTextContent = NSString(string: "Stand")
        CGContextSaveGState(context!)
        CGContextSetShadowWithColor(context!, shadow.shadowOffset, shadow.shadowBlurRadius, (shadow.shadowColor as! UIColor).CGColor)
        let standStyle = NSMutableParagraphStyle()
        standStyle.alignment = .Right

        let standFontAttributes = [NSFontAttributeName: UIFont.systemFontOfSize(UIFont.systemFontSize()), NSForegroundColorAttributeName: blue, NSParagraphStyleAttributeName: standStyle]

        let standTextHeight: CGFloat = standTextContent.boundingRectWithSize(CGSize(width: standRect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: standFontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, standRect)
        standTextContent.drawInRect(CGRect(x: standRect.minX, y: standRect.minY + (standRect.height - standTextHeight) / 2, width: standRect.width, height: standTextHeight), withAttributes: standFontAttributes)
        CGContextRestoreGState(context!)
        CGContextRestoreGState(context!)





        //// Arrow
        //// Move Arrow
        //// Bezier Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 83.5, 18.5)

        let bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPoint(x: -6, y: -0))
        bezierPath.addCurveToPoint(CGPoint(x: -0, y: 0), controlPoint1: CGPoint(x: 0.05, y: -0), controlPoint2: CGPoint(x: -1.5, y: -0))
        bezierPath.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezierPath.lineWidth = 2
        bezierPath.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 2 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 83.5, 18.5)
        CGContextRotateCTM(context!, -45 * CGFloat(M_PI) / 180)

        let bezier2Path = UIBezierPath()
        bezier2Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier2Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier2Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 3 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 83.5, 18.5)
        CGContextRotateCTM(context!, 45 * CGFloat(M_PI) / 180)

        let bezier3Path = UIBezierPath()
        bezier3Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier3Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier3Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier3Path.lineWidth = 2
        bezier3Path.stroke()

        CGContextRestoreGState(context!)




        //// Exercise Arrow
        //// Bezier 4 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 82.5, 36.5)

        let bezier4Path = UIBezierPath()
        bezier4Path.moveToPoint(CGPoint(x: -6, y: -0))
        bezier4Path.addCurveToPoint(CGPoint(x: -0, y: 0), controlPoint1: CGPoint(x: 0.05, y: -0), controlPoint2: CGPoint(x: -1.5, y: -0))
        bezier4Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier4Path.lineWidth = 2
        bezier4Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 5 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 82.5, 36.5)
        CGContextRotateCTM(context!, -45 * CGFloat(M_PI) / 180)

        let bezier5Path = UIBezierPath()
        bezier5Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier5Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier5Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier5Path.lineWidth = 2
        bezier5Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 6 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 82.5, 36.5)
        CGContextRotateCTM(context!, 45 * CGFloat(M_PI) / 180)

        let bezier6Path = UIBezierPath()
        bezier6Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier6Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier6Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier6Path.lineWidth = 2
        bezier6Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 7 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 86, 36.5)
        CGContextRotateCTM(context!, -45 * CGFloat(M_PI) / 180)

        let bezier7Path = UIBezierPath()
        bezier7Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier7Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier7Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier7Path.lineWidth = 2
        bezier7Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 8 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 86, 36.5)
        CGContextRotateCTM(context!, 45 * CGFloat(M_PI) / 180)

        let bezier8Path = UIBezierPath()
        bezier8Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier8Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier8Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier8Path.lineWidth = 2
        bezier8Path.stroke()

        CGContextRestoreGState(context!)




        //// Move Arrow 2
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 81, 54.5)
        CGContextRotateCTM(context!, -90 * CGFloat(M_PI) / 180)



        //// Bezier 9 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 3, 0)

        let bezier9Path = UIBezierPath()
        bezier9Path.moveToPoint(CGPoint(x: -6, y: -0))
        bezier9Path.addCurveToPoint(CGPoint(x: -0, y: 0), controlPoint1: CGPoint(x: 0.05, y: -0), controlPoint2: CGPoint(x: -1.5, y: -0))
        bezier9Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier9Path.lineWidth = 2
        bezier9Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 10 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 3, 0)
        CGContextRotateCTM(context!, -45 * CGFloat(M_PI) / 180)

        let bezier10Path = UIBezierPath()
        bezier10Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier10Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier10Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier10Path.lineWidth = 2
        bezier10Path.stroke()

        CGContextRestoreGState(context!)


        //// Bezier 11 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 3, 0)
        CGContextRotateCTM(context!, 45 * CGFloat(M_PI) / 180)

        let bezier11Path = UIBezierPath()
        bezier11Path.moveToPoint(CGPoint(x: -4, y: -0))
        bezier11Path.addCurveToPoint(CGPoint(x: 0, y: 0), controlPoint1: CGPoint(x: 0.03, y: -0), controlPoint2: CGPoint(x: -1, y: -0))
        bezier11Path.lineCapStyle = .Round;

        UIColor.blackColor().setStroke()
        bezier11Path.lineWidth = 2
        bezier11Path.stroke()

        CGContextRestoreGState(context!)



        CGContextRestoreGState(context!)




        CGContextEndTransparencyLayer(context!)
        CGContextRestoreGState(context!)
    }

    public class func drawMyActivity(frame frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 160)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Symbol Drawing
        let symbolRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 160)
        CGContextSaveGState(context!)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context!, symbolRect.origin.x, symbolRect.origin.y)

        LWActivity.drawActivityComposition()
        CGContextRestoreGState(context!)
    }

}
