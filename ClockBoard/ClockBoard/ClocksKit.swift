//
//  ClocksKit.swift
//  ClockBoard
//
//  Created by luowei on 2016/10/18.
//  Copyright (c) 2016 CompanyName. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class ClocksKit : NSObject {

    //// Drawing Methods

    public class func drawClock(numbersColor numbersColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), darkHandsColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), lightHandColor: UIColor = UIColor(red: 0.320, green: 0.800, blue: 0.638, alpha: 1.000), rimColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), tickColor: UIColor = UIColor(red: 0.668, green: 0.668, blue: 0.668, alpha: 1.000), faceColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000), hours: CGFloat = 9, minutes: CGFloat = 20, seconds: CGFloat = 62) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let expression = hours > 12 ? "PM" : "AM"
        let secondsAngle: CGFloat = -seconds / 60.0 * 360
        let minuteAngle: CGFloat = -(minutes / 60.0 * 360 - secondsAngle / 60.0)
        let hourAngle: CGFloat = -hours / 12.0 * 360 + minuteAngle / 12.0

        //// Oval 2 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)

        let oval2Path = UIBezierPath(ovalInRect: CGRect(x: -116, y: -116, width: 232, height: 232))
        rimColor.setFill()
        oval2Path.fill()

        CGContextRestoreGState(context!)


        //// Oval Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)

        let ovalPath = UIBezierPath(ovalInRect: CGRect(x: -110, y: -110, width: 220, height: 220))
        faceColor.setFill()
        ovalPath.fill()

        CGContextRestoreGState(context!)


        //// Text Drawing
        let textPath = UIBezierPath()
        textPath.moveToPoint(CGPoint(x: 123.72, y: 38.95))
        textPath.addLineToPoint(CGPoint(x: 120.22, y: 41.82))
        textPath.addLineToPoint(CGPoint(x: 118.47, y: 39.75))
        textPath.addLineToPoint(CGPoint(x: 124, y: 35.3))
        textPath.addLineToPoint(CGPoint(x: 126.72, y: 35.3))
        textPath.addLineToPoint(CGPoint(x: 126.72, y: 53))
        textPath.addLineToPoint(CGPoint(x: 123.72, y: 53))
        textPath.addLineToPoint(CGPoint(x: 123.72, y: 38.95))
        textPath.closePath()
        textPath.moveToPoint(CGPoint(x: 130.72, y: 50.25))
        textPath.addLineToPoint(CGPoint(x: 137.55, y: 43.55))
        textPath.addCurveToPoint(CGPoint(x: 138.86, y: 41.94), controlPoint1: CGPoint(x: 138.1, y: 43.02), controlPoint2: CGPoint(x: 138.54, y: 42.48))
        textPath.addCurveToPoint(CGPoint(x: 139.35, y: 40.07), controlPoint1: CGPoint(x: 139.19, y: 41.4), controlPoint2: CGPoint(x: 139.35, y: 40.78))
        textPath.addCurveToPoint(CGPoint(x: 138.54, y: 38.09), controlPoint1: CGPoint(x: 139.35, y: 39.24), controlPoint2: CGPoint(x: 139.08, y: 38.58))
        textPath.addCurveToPoint(CGPoint(x: 136.53, y: 37.35), controlPoint1: CGPoint(x: 138, y: 37.6), controlPoint2: CGPoint(x: 137.33, y: 37.35))
        textPath.addCurveToPoint(CGPoint(x: 134.47, y: 38.21), controlPoint1: CGPoint(x: 135.67, y: 37.35), controlPoint2: CGPoint(x: 134.99, y: 37.64))
        textPath.addCurveToPoint(CGPoint(x: 133.53, y: 40.38), controlPoint1: CGPoint(x: 133.96, y: 38.79), controlPoint2: CGPoint(x: 133.64, y: 39.51))
        textPath.addLineToPoint(CGPoint(x: 130.6, y: 39.93))
        textPath.addCurveToPoint(CGPoint(x: 131.22, y: 37.9), controlPoint1: CGPoint(x: 130.68, y: 39.19), controlPoint2: CGPoint(x: 130.89, y: 38.52))
        textPath.addCurveToPoint(CGPoint(x: 132.5, y: 36.3), controlPoint1: CGPoint(x: 131.56, y: 37.28), controlPoint2: CGPoint(x: 131.98, y: 36.75))
        textPath.addCurveToPoint(CGPoint(x: 134.31, y: 35.24), controlPoint1: CGPoint(x: 133.02, y: 35.85), controlPoint2: CGPoint(x: 133.62, y: 35.5))
        textPath.addCurveToPoint(CGPoint(x: 136.57, y: 34.85), controlPoint1: CGPoint(x: 135, y: 34.98), controlPoint2: CGPoint(x: 135.76, y: 34.85))
        textPath.addCurveToPoint(CGPoint(x: 138.79, y: 35.18), controlPoint1: CGPoint(x: 137.34, y: 34.85), controlPoint2: CGPoint(x: 138.08, y: 34.96))
        textPath.addCurveToPoint(CGPoint(x: 140.68, y: 36.16), controlPoint1: CGPoint(x: 139.5, y: 35.39), controlPoint2: CGPoint(x: 140.12, y: 35.72))
        textPath.addCurveToPoint(CGPoint(x: 141.99, y: 37.79), controlPoint1: CGPoint(x: 141.23, y: 36.6), controlPoint2: CGPoint(x: 141.66, y: 37.15))
        textPath.addCurveToPoint(CGPoint(x: 142.47, y: 40.03), controlPoint1: CGPoint(x: 142.31, y: 38.43), controlPoint2: CGPoint(x: 142.47, y: 39.17))
        textPath.addCurveToPoint(CGPoint(x: 142.25, y: 41.61), controlPoint1: CGPoint(x: 142.47, y: 40.59), controlPoint2: CGPoint(x: 142.4, y: 41.12))
        textPath.addCurveToPoint(CGPoint(x: 141.64, y: 43), controlPoint1: CGPoint(x: 142.1, y: 42.1), controlPoint2: CGPoint(x: 141.9, y: 42.57))
        textPath.addCurveToPoint(CGPoint(x: 140.74, y: 44.24), controlPoint1: CGPoint(x: 141.38, y: 43.43), controlPoint2: CGPoint(x: 141.08, y: 43.85))
        textPath.addCurveToPoint(CGPoint(x: 139.62, y: 45.38), controlPoint1: CGPoint(x: 140.4, y: 44.63), controlPoint2: CGPoint(x: 140.03, y: 45.01))
        textPath.addLineToPoint(CGPoint(x: 134.53, y: 50.25))
        textPath.addLineToPoint(CGPoint(x: 142.5, y: 50.25))
        textPath.addLineToPoint(CGPoint(x: 142.5, y: 53))
        textPath.addLineToPoint(CGPoint(x: 130.72, y: 53))
        textPath.addLineToPoint(CGPoint(x: 130.72, y: 50.25))
        textPath.closePath()
        numbersColor.setFill()
        textPath.fill()


        //// Bezier Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -(minuteAngle + 90) * CGFloat(M_PI) / 180)

        let bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPoint(x: 7.07, y: -7.07))
        bezierPath.addCurveToPoint(CGPoint(x: 9.54, y: -3), controlPoint1: CGPoint(x: 8.25, y: -5.89), controlPoint2: CGPoint(x: 9.07, y: -4.49))
        bezierPath.addLineToPoint(CGPoint(x: 95, y: -3))
        bezierPath.addLineToPoint(CGPoint(x: 95, y: 3))
        bezierPath.addLineToPoint(CGPoint(x: 9.54, y: 3))
        bezierPath.addCurveToPoint(CGPoint(x: 7.07, y: 7.07), controlPoint1: CGPoint(x: 9.07, y: 4.49), controlPoint2: CGPoint(x: 8.25, y: 5.89))
        bezierPath.addCurveToPoint(CGPoint(x: -7.07, y: 7.07), controlPoint1: CGPoint(x: 3.17, y: 10.98), controlPoint2: CGPoint(x: -3.17, y: 10.98))
        bezierPath.addCurveToPoint(CGPoint(x: -7.07, y: -7.07), controlPoint1: CGPoint(x: -10.98, y: 3.17), controlPoint2: CGPoint(x: -10.98, y: -3.17))
        bezierPath.addCurveToPoint(CGPoint(x: 7.07, y: -7.07), controlPoint1: CGPoint(x: -3.17, y: -10.98), controlPoint2: CGPoint(x: 3.17, y: -10.98))
        bezierPath.closePath()
        darkHandsColor.setFill()
        bezierPath.fill()

        CGContextRestoreGState(context!)


        //// Bezier 2 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -(hourAngle + 90) * CGFloat(M_PI) / 180)

        let bezier2Path = UIBezierPath()
        bezier2Path.moveToPoint(CGPoint(x: 7.07, y: -7.07))
        bezier2Path.addCurveToPoint(CGPoint(x: 8.66, y: -5), controlPoint1: CGPoint(x: 7.7, y: -6.44), controlPoint2: CGPoint(x: 8.24, y: -5.74))
        bezier2Path.addLineToPoint(CGPoint(x: 56, y: -5))
        bezier2Path.addLineToPoint(CGPoint(x: 56, y: 5))
        bezier2Path.addLineToPoint(CGPoint(x: 8.66, y: 5))
        bezier2Path.addCurveToPoint(CGPoint(x: 7.07, y: 7.07), controlPoint1: CGPoint(x: 8.24, y: 5.74), controlPoint2: CGPoint(x: 7.7, y: 6.44))
        bezier2Path.addCurveToPoint(CGPoint(x: -7.07, y: 7.07), controlPoint1: CGPoint(x: 3.17, y: 10.98), controlPoint2: CGPoint(x: -3.17, y: 10.98))
        bezier2Path.addCurveToPoint(CGPoint(x: -7.07, y: -7.07), controlPoint1: CGPoint(x: -10.98, y: 3.17), controlPoint2: CGPoint(x: -10.98, y: -3.17))
        bezier2Path.addCurveToPoint(CGPoint(x: 7.07, y: -7.07), controlPoint1: CGPoint(x: -3.17, y: -10.98), controlPoint2: CGPoint(x: 3.17, y: -10.98))
        bezier2Path.closePath()
        darkHandsColor.setFill()
        bezier2Path.fill()

        CGContextRestoreGState(context!)


        //// Bezier 3 Drawing
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -(secondsAngle + 90) * CGFloat(M_PI) / 180)

        let bezier3Path = UIBezierPath()
        bezier3Path.moveToPoint(CGPoint(x: 4.24, y: -4.24))
        bezier3Path.addCurveToPoint(CGPoint(x: 5.92, y: -1), controlPoint1: CGPoint(x: 5.16, y: -3.33), controlPoint2: CGPoint(x: 5.72, y: -2.19))
        bezier3Path.addLineToPoint(CGPoint(x: 99, y: -1))
        bezier3Path.addLineToPoint(CGPoint(x: 99, y: 1))
        bezier3Path.addLineToPoint(CGPoint(x: 5.92, y: 1))
        bezier3Path.addCurveToPoint(CGPoint(x: 4.24, y: 4.24), controlPoint1: CGPoint(x: 5.72, y: 2.19), controlPoint2: CGPoint(x: 5.16, y: 3.33))
        bezier3Path.addCurveToPoint(CGPoint(x: -4.24, y: 4.24), controlPoint1: CGPoint(x: 1.9, y: 6.59), controlPoint2: CGPoint(x: -1.9, y: 6.59))
        bezier3Path.addCurveToPoint(CGPoint(x: -4.24, y: -4.24), controlPoint1: CGPoint(x: -6.59, y: 1.9), controlPoint2: CGPoint(x: -6.59, y: -1.9))
        bezier3Path.addCurveToPoint(CGPoint(x: 4.24, y: -4.24), controlPoint1: CGPoint(x: -1.9, y: -6.59), controlPoint2: CGPoint(x: 1.9, y: -6.59))
        bezier3Path.closePath()
        lightHandColor.setFill()
        bezier3Path.fill()

        CGContextRestoreGState(context!)


        //// Group
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 127, y: 20, width: 6, height: 8))
        tickColor.setFill()
        rectanglePath.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 127, y: 232, width: 6, height: 8))
        tickColor.setFill()
        rectangle2Path.fill()




        //// Group 2
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, 90 * CGFloat(M_PI) / 180)



        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(rect: CGRect(x: -3, y: -110, width: 6, height: 8))
        tickColor.setFill()
        rectangle3Path.fill()


        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: -3, y: 102, width: 6, height: 8))
        tickColor.setFill()
        rectangle4Path.fill()



        CGContextRestoreGState(context!)


        //// Group 3
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -30 * CGFloat(M_PI) / 180)



        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath(rect: CGRect(x: -3, y: -110, width: 6, height: 8))
        tickColor.setFill()
        rectangle5Path.fill()


        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath(rect: CGRect(x: -3, y: 102, width: 6, height: 8))
        tickColor.setFill()
        rectangle6Path.fill()



        CGContextRestoreGState(context!)


        //// Group 4
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -60 * CGFloat(M_PI) / 180)



        //// Rectangle 7 Drawing
        let rectangle7Path = UIBezierPath(rect: CGRect(x: -3, y: -110, width: 6, height: 8))
        tickColor.setFill()
        rectangle7Path.fill()


        //// Rectangle 8 Drawing
        let rectangle8Path = UIBezierPath(rect: CGRect(x: -3, y: 102, width: 6, height: 8))
        tickColor.setFill()
        rectangle8Path.fill()



        CGContextRestoreGState(context!)


        //// Group 5
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -120 * CGFloat(M_PI) / 180)



        //// Rectangle 9 Drawing
        let rectangle9Path = UIBezierPath(rect: CGRect(x: -3, y: -110, width: 6, height: 8))
        tickColor.setFill()
        rectangle9Path.fill()


        //// Rectangle 10 Drawing
        let rectangle10Path = UIBezierPath(rect: CGRect(x: -3, y: 102, width: 6, height: 8))
        tickColor.setFill()
        rectangle10Path.fill()



        CGContextRestoreGState(context!)


        //// Group 6
        CGContextSaveGState(context!)
        CGContextTranslateCTM(context!, 130, 130)
        CGContextRotateCTM(context!, -150 * CGFloat(M_PI) / 180)



        //// Rectangle 11 Drawing
        let rectangle11Path = UIBezierPath(rect: CGRect(x: -3, y: -110, width: 6, height: 8))
        tickColor.setFill()
        rectangle11Path.fill()


        //// Rectangle 12 Drawing
        let rectangle12Path = UIBezierPath(rect: CGRect(x: -3, y: 102, width: 6, height: 8))
        tickColor.setFill()
        rectangle12Path.fill()



        CGContextRestoreGState(context!)


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 111, y: 198, width: 38, height: 40)
        let text2TextContent = NSString(string: "6")
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .Center

        let text2FontAttributes = [NSFontAttributeName: UIFont(name: "AvenirNext-DemiBold", size: 25)!, NSForegroundColorAttributeName: numbersColor, NSParagraphStyleAttributeName: text2Style]

        let text2TextHeight: CGFloat = text2TextContent.boundingRectWithSize(CGSize(width: text2Rect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, text2Rect)
        text2TextContent.drawInRect(CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        CGContextRestoreGState(context!)


        //// Text 3 Drawing
        let text3Rect = CGRect(x: 201, y: 110, width: 38, height: 40)
        let text3TextContent = NSString(string: "3")
        let text3Style = NSMutableParagraphStyle()
        text3Style.alignment = .Center

        let text3FontAttributes = [NSFontAttributeName: UIFont(name: "AvenirNext-DemiBold", size: 25)!, NSForegroundColorAttributeName: numbersColor, NSParagraphStyleAttributeName: text3Style]

        let text3TextHeight: CGFloat = text3TextContent.boundingRectWithSize(CGSize(width: text3Rect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: text3FontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, text3Rect)
        text3TextContent.drawInRect(CGRect(x: text3Rect.minX, y: text3Rect.minY + (text3Rect.height - text3TextHeight) / 2, width: text3Rect.width, height: text3TextHeight), withAttributes: text3FontAttributes)
        CGContextRestoreGState(context!)


        //// Text 4 Drawing
        let text4Rect = CGRect(x: 22, y: 110, width: 38, height: 40)
        let text4TextContent = NSString(string: "9")
        let text4Style = NSMutableParagraphStyle()
        text4Style.alignment = .Center

        let text4FontAttributes = [NSFontAttributeName: UIFont(name: "AvenirNext-DemiBold", size: 25)!, NSForegroundColorAttributeName: numbersColor, NSParagraphStyleAttributeName: text4Style]

        let text4TextHeight: CGFloat = text4TextContent.boundingRectWithSize(CGSize(width: text4Rect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: text4FontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, text4Rect)
        text4TextContent.drawInRect(CGRect(x: text4Rect.minX, y: text4Rect.minY + (text4Rect.height - text4TextHeight) / 2, width: text4Rect.width, height: text4TextHeight), withAttributes: text4FontAttributes)
        CGContextRestoreGState(context!)


        //// Text 13 Drawing
        let text13Rect = CGRect(x: 99, y: 144, width: 62, height: 34)
        let text13Style = NSMutableParagraphStyle()
        text13Style.alignment = .Center

        let text13FontAttributes = [NSFontAttributeName: UIFont(name: "AvenirNext-DemiBold", size: 20)!, NSForegroundColorAttributeName: numbersColor, NSParagraphStyleAttributeName: text13Style]

        let text13TextHeight: CGFloat = NSString(string: expression).boundingRectWithSize(CGSize(width: text13Rect.width, height: CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: text13FontAttributes, context: nil).size.height
        CGContextSaveGState(context!)
        CGContextClipToRect(context!, text13Rect)
        NSString(string: expression).drawInRect(CGRect(x: text13Rect.minX, y: text13Rect.minY + (text13Rect.height - text13TextHeight) / 2, width: text13Rect.width, height: text13TextHeight), withAttributes: text13FontAttributes)
        CGContextRestoreGState(context!)
    }

    public class func drawClockPlayground(frame frame: CGRect = CGRect(x: 32, y: 21, width: 288, height: 109), numbersColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), darkHandsColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), lightHandColor: UIColor = UIColor(red: 0.320, green: 0.800, blue: 0.638, alpha: 1.000), rimColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000), tickColor: UIColor = UIColor(red: 0.668, green: 0.668, blue: 0.668, alpha: 1.000), faceColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let color = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let color2 = UIColor(red: 0.219, green: 0.373, blue: 0.457, alpha: 1.000)
        let color3 = UIColor(red: 0.290, green: 0.290, blue: 0.290, alpha: 1.000)
        let color4 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let color5 = UIColor(red: 0.086, green: 0.846, blue: 0.850, alpha: 1.000)

        //// Clock1 Drawing
        let clock1Rect = CGRect(x: frame.minX - 2, y: frame.minY + 4, width: frame.width - 188, height: frame.height - 9)
        CGContextSaveGState(context!)
        UIRectClip(clock1Rect)
        CGContextTranslateCTM(context!, clock1Rect.origin.x, clock1Rect.origin.y)
        CGContextScaleCTM(context!, clock1Rect.size.width / 260, clock1Rect.size.height / 260)

        ClocksKit.drawClock(numbersColor: color5, darkHandsColor: color2, lightHandColor: color, rimColor: color2, tickColor: tickColor, faceColor: faceColor, hours: 15, minutes: 56, seconds: 40)
        CGContextRestoreGState(context!)


        //// Clock2 Drawing
        let clock2Rect = CGRect(x: frame.minX + 97, y: frame.minY + 6, width: frame.width - 188, height: frame.height - 9)
        CGContextSaveGState(context!)
        UIRectClip(clock2Rect)
        CGContextTranslateCTM(context!, clock2Rect.origin.x, clock2Rect.origin.y)
        CGContextScaleCTM(context!, clock2Rect.size.width / 260, clock2Rect.size.height / 260)

        ClocksKit.drawClock(numbersColor: numbersColor, darkHandsColor: darkHandsColor, lightHandColor: lightHandColor, rimColor: rimColor, tickColor: tickColor, faceColor: faceColor, hours: 23, minutes: 43, seconds: 15)
        CGContextRestoreGState(context!)


        //// Clock3 Drawing
        let clock3Rect = CGRect(x: frame.minX + 194, y: frame.minY + 6, width: frame.width - 188, height: frame.height - 9)
        CGContextSaveGState(context!)
        UIRectClip(clock3Rect)
        CGContextTranslateCTM(context!, clock3Rect.origin.x, clock3Rect.origin.y)
        CGContextScaleCTM(context!, clock3Rect.size.width / 260, clock3Rect.size.height / 260)

        ClocksKit.drawClock(numbersColor: color4, darkHandsColor: color4, lightHandColor: color5, rimColor: color4, tickColor: color4, faceColor: color3, hours: 14, minutes: -10, seconds: 43)
        CGContextRestoreGState(context!)
    }

}
